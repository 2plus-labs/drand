/*
 * This protobuf file contains the definition of the public API endpoints as
 * well as messages. All client implementations should use this reference
 * protobuf to implement a compatible drand client.
 */
syntax = "proto3";

package drand;

option go_package = "github.com/drand/drand/protobuf/drand";
/*option go_package = "drand";*/

import "drand/common.proto";
import "common/common.proto";

service Public {
    // PublicRand is the method that returns the publicly verifiable randomness
    // generated by the drand network.
    rpc PublicRand(PublicRandRequest) returns (PublicRandResponse);

    rpc PublicRandStream(PublicRandRequest) returns (stream PublicRandResponse);

    // ChainInfo returns the information related to the chain this node
    // participates to
    rpc ChainInfo(drand.ChainInfoRequest) returns (drand.ChainInfoPacket);

    // CoSign return signature and randomness base on msg for outside network
    rpc CoSign(CoSignRequest) returns (CoSignResponse);

    // SignMintProof return proof of minting
    rpc SignMintProof(MintProofRequest) returns (MintProofResponse);

    // SignWithdrawProof return proof of withdraw
    rpc SignWithdrawProof(WithdrawProofRequest) returns (WithdrawProofResponse);

    // Home is a simple endpoint
    rpc Home(HomeRequest) returns (HomeResponse);
}

// PublicRandRequest requests a public random value that has been generated in a
// unbiasable way and verifiable.
message PublicRandRequest {
    // round uniquely identifies a beacon. If round == 0 (or unspecified), then
    // the response will contain the last.
    uint64 round = 1;
    common.Metadata metadata = 2;
}

// PublicRandResponse holds a signature which is the random value. It can be
// verified thanks to the distributed public key of the nodes that have ran the
// DKG protocol and is unbiasable. The randomness can be verified using the BLS
// verification routine with the message "round || previous_rand".
message PublicRandResponse {
    uint64 round = 1;
    bytes signature = 2;
    bytes previous_signature = 3;
    // randomness is simply there to demonstrate - it is the hash of the
    // signature. It should be computed locally.
    bytes randomness = 4;
    common.Metadata metadata = 5;
}

message HomeRequest {
    common.Metadata metadata = 1;
}

message HomeResponse {
    string status = 1;
    common.Metadata metadata = 2;
}


message CoSignRequest{
    string msg = 1;
    uint64 round = 2;
    common.Metadata metadata = 3;
}

message CoSignResponse{
    string msg = 1;
    bytes signature = 2;
    bytes randomness = 3;
    bytes public_key = 4;
    uint64 round = 5;
    common.Metadata metadata = 6;
}

message MintProofRequest{
    string msg = 1;
    common.Metadata metadata = 2;
}

message MintProofResponse{
    string msg = 1;
    bytes signature = 2;
    bytes public_key = 3;
    uint64 round = 4;
    common.Metadata metadata = 5;
}

message WithdrawProofRequest{
    string msg = 1;
    common.Metadata metadata = 2;
}

message WithdrawProofResponse{
    string msg = 1;
    bytes signature = 2;
    bytes public_key = 3;
    uint64 round = 4;
    common.Metadata metadata = 5;
}