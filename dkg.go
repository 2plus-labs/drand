package main

import (
	"errors"
	"fmt"
	"sync"

	kyber "gopkg.in/dedis/kyber.v1"
	"gopkg.in/dedis/kyber.v1/share/pedersen/dkg"
	"gopkg.in/dedis/kyber.v1/util/random"
)

// DKG is the structure responsible for running the DKG protocol.
type DKG struct {
	priv    *Private
	list    Group
	n       int
	t       int
	idx     int
	group   kyber.Group
	router  *Router
	dkg     *dkg.DistKeyGenerator
	shareCh chan *dkg.DistKeyShare
	done    bool
	sync.Mutex
}

func NewDKG(priv *Private, list Group, r *Router) (*DKG, error) {
	d := &DKG{
		priv:   priv,
		list:   list,
		router: r,
		n:      len(list),
		// default threshold
		t:     len(list)/2 + 1,
		group: pairing.G2(),
	}
	d.idx, _ = list.Index(priv.Public)
	var err error
	// public key is in G2
	d.dkg, err = dkg.NewDistKeyGenerator(d.group.(dkg.Suite), d.priv.Key, list.Points(), random.Stream, d.t)
	return d, err
}

// Start initiates the DKG protocol, it actively connects to every other nodes
// as an initiator. It returns the share generated if the protocol proceeded
// correctly.
func (d *DKG) Start() (*dkg.DistKeyShare, error) {
	if err := d.sendDeals(); err != nil {
		return nil, err
	}
	share := <-d.shareCh
	return share, nil
}

// Run listens for any incoming DKG packet from an initiator. Once such a packet
// is received, it will start the DKG protocol by sending its shares. It returns
// the share generated by the protocol if it succeeded.
func (d *DKG) Run() (*dkg.DistKeyShare, error) {
	root, packet := d.router.Receive()
	deal, err := d.expectDeal(packet)
	if err != nil {
		return nil, err
	}
	fmt.Println(root, packet, deal)
	//d.processDeal(root, deal)

	share := <-d.shareCh
	return share, nil
}

func (d *DKG) sendDeals() error {
	panic("not impl. yet")
}

/*func (d *DKG) Process(p *Public, d *DKGPacket) {*/
//d.router.Receive()
//dkgPacket := cm.PDkg
//switch {
//case dkgPacket.Deal != nil:
//d.processDeal(id, dkgPacket.Deal)
//case dkgPacket.Response != nil:
//d.processResponse(id, dkgPacket.Response)
//case dkgPacket.Justification != nil:
//d.processJustification(id, dkgPacket.Justification)
//}
//}

//func (d *DKG) processDeal(id *Identity, deal *dkg.Deal) {
//resp, err := d.dkg.ProcessDeal(deal)
//if err != nil {
//slog.Fatal("dkg: deal error: " + err.Error())
//}
//msg := &ClientMessage{
//Type: PROTOCOL_PDKG,
//PDkg: &PDkg{
//Response: resp,
//},
//}

//if err := d.router.Broadcast(msg, d.participants...); err != nil {
//slog.Info("dkg: send response error", err)
//return
//}
//}

//func (d *DKG) processResponse(id *Identity, deal *dkg.Response) {
//j, err := d.dkg.ProcessResponse(deal)
//if err != nil {
//slog.Print("dkg: response invalid:", err)
//}

//if j != nil {
//msg := &ClientMessage{
//Type: PROTOCOL_PDKG,
//PDkg: &PDkg{
//Justification: j,
//},
//}
//if err := d.router.Broadcast(msg, d.participants...); err != nil {
//slog.Info("dkg: broadcasting justification:", err)
//}
//}

//if d.dkg.Certified() {
//dks, err := d.dkg.DistKeyShare()
//if err != nil {
//panic(err)
//}
//d.done = true
//d.shareCh <- dks
//}
//}

//func (d *DKG) processJustification(id *Identity, j *dkg.Justification) {

/*}*/

func (d *DKG) expectDeal(buff []byte) (*dkg.Deal, error) {
	drand, err := unmarshal(d.group, buff)
	if err != nil {
		return nil, err
	}

	if drand.Dkg == nil {
		return nil, errors.New("dkg: received non DKG packet...")
	}

	if drand.Dkg.Deal == nil {
		return nil, errors.New("dkg: expected a Deal but got none...")
	}
	return drand.Dkg.Deal, nil
}
