package main

import (
	"errors"
	"fmt"
	"sync"

	"github.com/nikkolasg/slog"

	"gopkg.in/dedis/kyber.v1/share/pedersen/dkg"
	"gopkg.in/dedis/kyber.v1/util/random"
)

// DKG is the structure responsible for running the DKG protocol.
type DKG struct {
	priv    *Private
	group   *Group
	addr    string
	n       int
	t       int
	idx     int
	router  *Router
	dkg     *dkg.DistKeyGenerator
	shareCh chan *dkg.DistKeyShare
	done    bool
	sync.Mutex
}

func NewDKG(priv *Private, group *Group, r *Router) (*DKG, error) {
	d := &DKG{
		priv:   priv,
		group:  group,
		router: r,
		n:      group.Len(),
		// default threshold
		t:    group.Threshold,
		addr: priv.Public.Address,
	}
	d.idx, _ = group.Index(priv.Public)
	var err error
	// public key is in G2
	d.dkg, err = dkg.NewDistKeyGenerator(g2.(dkg.Suite), d.priv.Key, group.Points(), random.Stream, d.t)
	return d, err
}

// Start initiates the DKG protocol, it actively connects to every other nodes
// as an initiator. It returns the share generated if the protocol proceeded
// correctly.
func (d *DKG) Start() (*dkg.DistKeyShare, error) {
	if err := d.sendDeals(true); err != nil {
		return nil, err
	}
	share := <-d.shareCh
	return share, nil
}

// Run listens for any incoming DKG packet from an initiator. Once such a packet
// is received, it will start the DKG protocol by sending its shares. It returns
// the share generated by the protocol if it succeeded.
func (d *DKG) Run() (*dkg.DistKeyShare, error) {
	_, packet := d.router.Receive()
	deal, err := d.expectDeal(packet)
	if err != nil {
		return nil, err
	}
	d.processDeal(deal)

	share := <-d.shareCh
	return share, nil
}

func (d *DKG) process(pub *Public, dkg *DKGPacket) {
	switch {
	case dkg.Deal != nil:
		d.processDeal(dkg.Deal)
	case dkg.Response != nil:
		d.processResponse(dkg.Response)
	case dkg.Justification != nil:
		panic("not yet implemented")
	}
}

func (d *DKG) processDeal(deal *dkg.Deal) {
	resp, err := d.dkg.ProcessDeal(deal)
	if err != nil {
		slog.Infof("%s error processing deal: %s", d.addr, err)
		return
	}
	packet := &DrandPacket{
		Dkg: &DKGPacket{
			Response: resp,
		},
	}
	d.broadcast(packet)
}

func (d *DKG) processResponse(resp *dkg.Response) {
	j, err := d.dkg.ProcessResponse(resp)
	if err != nil {
		slog.Infof("%s error process response: %s", d.addr, err)
	}
	if j == nil {
		return
	}
	packet := &DrandPacket{
		Dkg: &DKGPacket{
			Justification: j,
		},
	}
	d.broadcast(packet)
}

// sendDeals tries to send the deals to each of the nodes. force indicates if
// the local nodeis the initiator or not, and therefore must actively initiates
// the connection or not.
// It returns an error if a number of node superior to the threshold have not
// received the deal. It is basically a no-go.
func (d *DKG) sendDeals(force bool) error {
	deals, err := d.dkg.Deals()
	if err != nil {
		return err
	}
	var send func(*Public, *DrandPacket) error
	if force {
		send = d.router.SendForce
	} else {
		send = d.router.Send
	}
	var good int = 1
	for i, deal := range deals {
		pub := d.group.Public(i)
		packet := &DrandPacket{
			Dkg: &DKGPacket{
				Deal: deal,
			},
		}
		if err := send(pub, packet); err != nil {
			slog.Debugf(d.priv.Public.Address, " failed to send deal to ", pub.Address)
		} else {
			good++
		}
	}
	if good < d.t {
		return fmt.Errorf("dkg: could only send deals to %d / %d (threshold %d)", good, d.n, d.t)
	}
	return nil
}

func (d *DKG) expectDeal(buff []byte) (*dkg.Deal, error) {
	drand, err := unmarshal(g2, buff)
	if err != nil {
		return nil, err
	}

	if drand.Dkg == nil {
		return nil, errors.New("dkg: received non DKG packet...")
	}

	if drand.Dkg.Deal == nil {
		return nil, errors.New("dkg: expected a Deal but got none...")
	}
	return drand.Dkg.Deal, nil
}

func (d *DKG) broadcast(packet *DrandPacket) {
	for _, ip := range d.group.List {
		if err := d.router.Send(ip.Public, packet); err != nil {
			slog.Debugf("%s error sending packet to %s: %s", d.addr, ip.Address, err)
		}
	}
}
