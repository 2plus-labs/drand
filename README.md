[![Build Status](https://travis-ci.org/dedis/drand.svg?branch=master)](https://travis-ci.org/dedis/drand)

# Drand - A Distributed Randomness Beacon Daemon

Drand (pronounced "dee-rand") is a distributed randomness beacon daemon written
in [Golang](https://golang.org/). Servers that run drand can be linked with each
other to produce collective, publicly verifiable, unbiasable, unpredictable
random values at fixed intervals using pairing-based threshold cryptography.

### Disclaimer

**This software is considered experimental and has NOT received a
full audit yet. Therefore, DO NOT USE it in production at this point. You have
been warned.**

## Drand in a Nutshell

A drand beacon comprises several nodes, each of which has its own long-term
public/private key pair. A *group file* contains all the participants' public
keys together with some further metadata required to operate the beacon. Drand
has two phases:

- **Setup:** After the group file has been distributed, all participants run a
    *distributed key generation* (DKG) protocol to compute the collective public
    key and one private key share per node. The participants NEVER see/use the
    actual private key explicitly but instead utilize their respective private
    key shares for drand's cryptographic operations.

- **Generation:** After the setup, the participating nodes switch to the
    randomness generation mode. Any of the nodes can then function as a leader
    which runs beacon rounds at fixed intervals to produce collective random
    values together with a threshold of available nodes. Each beacon value is a
    compact *Boneh-Lynn-Shacham* (BLS) signature that can be efficiently
    verified against the collective public key computed during setup. Due to the
    properties of BLS signatures, they can be used as a source for public
    randomness.

## Installation 

Drand can be installed via [Golang](https://golang.org/) or [Docker](https://www.docker.com/). 

### Via Docker

1. Make sure that you have a working [Docker installation](https://docs.docker.com/engine/installation/). 
2. Create drand's main folder where the daemon stores its long-term key pair,
the group file, the collective public key, etc., via:
```
mkdir ~/.drand/
```
3. A given drand command can be launched as follows:
```
docker run --rm --name drand -p <port>:<port> -v ~/.drand/:/root/.drand/ dedis/drand <command>
```
This in particular downloads the [drand image](https://hub.docker.com/r/dedis/drand/) 
from Docker Hub and installs it. Moreover, `<port>` is the port that your
container uses to communicate with the other participants and `~/.drand/` is the
folder with drand's configuration and output files.

### Via Golang

1. Make sure that you have a working [Golang installation](https://golang.org/doc/install) and that your [GOPATH](https://golang.org/doc/code.html#GOPATH) is set.
2. **TODO: install the DFINITY crypto library?**
3. Install drand via:
```
go get github.com/dedis/drand
```

## Usage

There are different stages that need to run in order to have a fully functional
drand beacon.

### Key generation

Each node generates their keypair using
```
drand keygen <address>
```
where address is in the form <ip>:<port>. The address is attached to the public
key so each node must be reachable at the address they specified.
By default, your keys are saved under `$HOME/.drand/drand_id.{secret,public}`.

### Group generation

To generate the group file listing all public keys, simply run:
```
drand group <pk1> <pk2> ... <pkn>
```
where <pkn> is the public key file of the n-th participant.
The group file is generated by default under `$HOME/.drand/drand_group.toml`.
That group file MUST be distributed to each of the node; it's best if the group
file is saved at the same place so there is no need for specifying the location
to drand.

### Beacon 

At the point, there needs to be a designated special node called the leader that
starts the protocol at a fixed interval. 
For the leader, run:
```
drand run --leader
```
or
```
drand run
```
for all other nodes.

The dealer can choose the period to wait between two runs with the `--period
DURATION` flag. DURATION can be for example `1mn` or `30s` (in fact, everything
understood by Golang's [duration
parsing](https://golang.org/pkg/time/#ParseDuration).

This command first runs first the Distributed Key Generation protocol, saves
the private share and the distributed public key in
`~/.drand/drand_id.{secret,public}`.
All signatures are by default saved under `~/.drand/beacons/<timestamp>.sig`.

**The distributed public key is generated under `~/.drand/drand_id.public`**.

### Verify a beacon

In order to verify that a beacon has been generated correctly, the verifier
needs two things:
 + the distributed public key generated during the DKG step. Default place is
   `~/.drand/drand_id.public`
 + the beacon signature, one in the default place `~/.drand/beacons/`.

 Simply run:
 ```
 drand verify --distkey <distkey_file> <beacon_file>
 ```

 The command outputs if the signature is valid or not, and returns 0 if the signature is valid, 1 otherwise. 

## What's this crypto magic?

drand relies on well known protocol and concepts. 
+ drand uses pairing based cryptography for all its protocols. Drand uses an
  optimized implementation of the [Barreto-Naehrig
  curves](https://github.com/dfinity/bn).
+ drand uses a distributed key generation (DKG) protocol to generate a
  distributed key where no node individual node can recover the private key but
  the public key is known. Only a threshold of nodes can actually recover the
  private key if they collude together. drand currently uses an implementation
  of the basic Pedersen which is currently being revised due to some
  implementation issues.  The next goal would be to try the [Distributed Key
  Generation in the Wild](https://eprint.iacr.org/2012/377.pdf) protocol from
  Aniket & Goldberg allowing for more realistic network assumptions.
+ drand uses the BLS signature scheme but in the threshold setting. Instead of
  signing with a private key, each node signs with a private share of the
  distributed private key. A node collects at most a threshold of these partial
  signatures to reconstruct (using Lagrange interpolation) the BLS signature
  that can be verified under the distributed public key. For more info, see the
  [paper](https://www.iacr.org/archive/asiacrypt2001/22480516.pdf).

## What's next

Drand is at its early stage, so there's a lot to be done and its evolution is
dependent of the public's interest. Feel free to requests features in issues, or
even better, to submit pull requests ;) 
See the [TODO](https://github.com/dedis/drand/blob/master/TODO.md) file for more
information.

## Acknowledgments

Thanks to [@Daeinar](https://github.com/Daeinar) for the long discussions and
design decisions about drand.  Thanks to [@herumi](https://github.com/herumi)
for support with his optimized pairing based cryptographic library.
