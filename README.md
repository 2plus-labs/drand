[![Build Status](https://travis-ci.org/dedis/drand.svg?branch=master)](https://travis-ci.org/dedis/drand)

# Drand - A Distributed Randomness Beacon Daemon

Drand (pronounced "dee-rand") is a distributed randomness beacon daemon written
in [Golang](https://golang.org/). Servers that run drand can be linked with each
other to produce collective, publicly verifiable, unbiasable, unpredictable
random values at fixed intervals using pairing-based threshold cryptography.

### Disclaimer

**This software is considered experimental and has NOT received a
full audit yet. Therefore, DO NOT USE it in production at this point. You have
been warned.**

## Drand in a Nutshell

A drand beacon is created from a list of nodes and has two two phases:

- **Setup:** Each node first generates a *long-term public/private key
    pair*. Afterwards, a *group file* is created which gathers all the
    participants' public keys together with some further metadata required to
    operate the beacon. After the group file has been distributed, all
    participants run a *distributed key generation* (DKG) protocol to create
    the collective public key and one private key share per node. The
    participants NEVER see/use the actual private key explicitly but instead
    utilize their respective private key shares for drand's cryptographic
    operations.

- **Generation:** After the setup, the participating nodes switch to the
    randomness generation mode. Any of the nodes can then function as a leader
    which runs beacon rounds at fixed intervals to produce collective random
    values together with a threshold of available nodes. Each beacon value is a
    compact *Boneh-Lynn-Shacham* (BLS) signature that can be efficiently
    verified against the collective public key computed during setup. Due to the
    properties of BLS signatures, they can be used as a source for public
    randomness.

## Installation 

Drand can be installed via [Golang](https://golang.org/) or [Docker](https://www.docker.com/). 
As a first step create drand's application folder where configuration files
such as the long-term key pair, the group file, and the collective public key
are stored:
```
mkdir ~/.drand/
```

### Via Docker

1. Make sure that you have a working [Docker installation](https://docs.docker.com/engine/installation/). 
2. Pull the latest [drand image](https://hub.docker.com/r/dedis/drand/) from Docker Hub: 
```
docker pull dedis/drand
```

### Via Golang

1. Make sure that you have a working [Golang installation](https://golang.org/doc/install) and that your [GOPATH](https://golang.org/doc/code.html#GOPATH) is set.
2. **TODO: install the DFINITY crypto library?**
3. Install drand via:
```
go get github.com/dedis/drand
```

## Usage

**NOTE:** If you run drand in Docker, always use the following template
```
docker run \ 
    --rm \ 
    --name drand 
    --port <port>:<port> \ 
    --volume $HOME/drand/:/root/.drand/ \ 
    dedis/<command>
```
where `<command>` has to be substituted by the respective drand commands below.

### Setup

First we need to setup the drand daemon by generating its long-term key pair and
setting up the group configuration file `group.toml`.

#### Long-Term Key

To generate the long-term key pair `drand_id.{secret,public}` of the drand daemon, execute
```
drand keygen <ip>:<port>
```
where `<ip>:<port>` is the address from which your drand daemon is reachable.


#### Group Configuration

To generate the group configuration file `drand_group.toml`, run:
```
drand group <pk1> <pk2> ... <pkn>
```
where `<pki>` is the public key file `drand_id.public` of the i-th participant.

**NOTE:** This group file MUST be distributed to all participants.


### Generation




There are different stages that need to run in order to have a fully functional
drand beacon.

### Key generation

Each node generates their keypair using
```
drand keygen <ip>:<port>
```
where address is in the form <ip>:<port>. The address is attached to the public
key so each node must be reachable at the address they specified.
By default, your keys are saved under `$HOME/.drand/drand_id.{secret,public}`.

### Group generation

To generate the group file listing all public keys, simply run:
```
drand group <pk1> <pk2> ... <pkn>
```
where <pkn> is the public key file of the n-th participant.
The group file is generated by default under `$HOME/.drand/drand_group.toml`.
That group file MUST be distributed to each of the node; it's best if the group
file is saved at the same place so there is no need for specifying the location
to drand.

### Beacon 

At the point, there needs to be a designated special node called the leader that
starts the protocol at a fixed interval. 
For the leader, run:
```
drand run --leader
```
or
```
drand run
```
for all other nodes.

The dealer can choose the period to wait between two runs with the `--period
DURATION` flag. DURATION can be for example `1mn` or `30s` (in fact, everything
understood by Golang's [duration
parsing](https://golang.org/pkg/time/#ParseDuration).

This command first runs first the Distributed Key Generation protocol, saves
the private share and the distributed public key in
`~/.drand/drand_id.{secret,public}`.
All signatures are by default saved under `~/.drand/beacons/<timestamp>.sig`.

**The distributed public key is generated under `~/.drand/drand_id.public`**.

### Verify a beacon

In order to verify that a beacon has been generated correctly, the verifier
needs two things:
 + the distributed public key generated during the DKG step. Default place is
   `~/.drand/drand_id.public`
 + the beacon signature, one in the default place `~/.drand/beacons/`.

 Simply run:
 ```
 drand verify --distkey <distkey_file> <beacon_file>
 ```

 The command outputs if the signature is valid or not, and returns 0 if the signature is valid, 1 otherwise. 

## What's this crypto magic?

drand relies on well known protocol and concepts. 
+ drand uses pairing based cryptography for all its protocols. Drand uses an
  optimized implementation of the [Barreto-Naehrig
  curves](https://github.com/dfinity/bn).
+ drand uses a distributed key generation (DKG) protocol to generate a
  distributed key where no node individual node can recover the private key but
  the public key is known. Only a threshold of nodes can actually recover the
  private key if they collude together. drand currently uses an implementation
  of the basic Pedersen which is currently being revised due to some
  implementation issues.  The next goal would be to try the [Distributed Key
  Generation in the Wild](https://eprint.iacr.org/2012/377.pdf) protocol from
  Aniket & Goldberg allowing for more realistic network assumptions.
+ drand uses the BLS signature scheme but in the threshold setting. Instead of
  signing with a private key, each node signs with a private share of the
  distributed private key. A node collects at most a threshold of these partial
  signatures to reconstruct (using Lagrange interpolation) the BLS signature
  that can be verified under the distributed public key. For more info, see the
  [paper](https://www.iacr.org/archive/asiacrypt2001/22480516.pdf).

## What's next

Drand is at its early stage, so there's a lot to be done and its evolution is
dependent of the public's interest. Feel free to requests features in issues, or
even better, to submit pull requests ;) 
See the [TODO](https://github.com/dedis/drand/blob/master/TODO.md) file for more
information.

## Acknowledgments

Thanks to [@Daeinar](https://github.com/Daeinar) for the long discussions and
design decisions about drand.  Thanks to [@herumi](https://github.com/herumi)
for support with his optimized pairing based cryptographic library.
