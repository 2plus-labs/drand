package key

import (
	"errors"
	"io/ioutil"
	"os"
	"path"
	"reflect"

	"github.com/BurntSushi/toml"
	"github.com/nikkolasg/slog"
)

// Store abstracts the loading and saving of any private/public cryptographic
// material to be used by drand. For the moment, only a file based store is
// implemented.
type Store interface {
	// SavePrivate saves the private key generated by drand as well as the
	// public identity key associated
	SavePrivate(p *Private) error
	// LoadPrivate loads the private/public key pair associated with the drand
	// operator
	LoadPrivate() (*Private, error)
	SaveShare(share *Share) error
	LoadShare() (*Share, error)
	SaveGroup(*Group) error
	LoadGroup() (*Group, error)
	SaveDistPublic(d *DistPublic) error
	LoadDistPublic() (*DistPublic, error)
}

var ErrStoreFile = errors.New("store file issues")
var ErrAbsent = errors.New("store can't find requested object")

const defaultConfigFolder = ".drand"

// ConfigFolderFlag holds the name of the flag to set using the CLI to change
// the default configuration folder of drand. It mimicks the gpg flag option.
const ConfigFolderFlag = "homedir"

const keyFolderName = "key"
const groupFolderName = "groups"
const keyFileName = "drand_id"
const privateExtension = ".private"
const publicExtension = ".public"
const groupFileName = "drand_group.toml"
const shareFileName = "dist_key.private"
const distKeyFileName = "dist_key.public"

// Tomler represents any struct that can be (un)marshalled into/from toml format
type Tomler interface {
	TOML() interface{}
	FromTOML(i interface{}) error
	TOMLValue() interface{}
}

// fileStore is a Store using filesystem to store informations
type fileStore struct {
	baseFolder     string
	privateKeyFile string
	publicKeyFile  string
	shareFile      string
	distKeyFile    string
	groupFile      string
}

// NewDefaultFileStore
func NewDefaultFileStore() Store {
	createSecureFolder(defaultConfigFolder)
	return newFileStore(defaultConfigFolder)
}

// NewFileStore
func NewFileStore(k KeyValue) Store {
	c := &context{k}
	baseFolder := c.String(ConfigFolderFlag, defaultConfigFolder)
	return newFileStore(baseFolder)
}

func newFileStore(baseFolder string) Store {
	fs := &fileStore{baseFolder: baseFolder}
	keyFolder := createSecureFolder(path.Join(baseFolder, keyFolderName))
	groupFolder := createSecureFolder(path.Join(baseFolder, groupFolderName))
	fs.privateKeyFile = path.Join(keyFolder, keyFileName) + privateExtension
	fs.publicKeyFile = path.Join(keyFolder, keyFileName) + publicExtension
	fs.groupFile = path.Join(groupFolder, groupFileName)
	fs.shareFile = path.Join(groupFolder, shareFileName)
	fs.distKeyFile = path.Join(groupFolder, distKeyFileName)
	return fs
}

// KeyValue is a store that returns a value under a key. It must returns a
// default value in case the key is not defined. Keys are defined above as
// XXXFlagName.
// Initially, cli.Context only fulfills this role but it's easy to imagine other
// implementations in the future (change of cli-framework or else).
type KeyValue interface {
	String(key string) string
	IsSet(key string) bool
}

// SaveKey first saves the private key in a file with tight permissions and then
// saves the public part in another file.
func (f *fileStore) SavePrivate(p *Private) error {
	if err := Save(f.privateKeyFile, p, true); err != nil {
		return err
	}
	return Save(f.publicKeyFile, p.Public, false)
}

// LoadKey decode private key first then public
func (f *fileStore) LoadPrivate() (*Private, error) {
	p := new(Private)
	if err := Load(f.privateKeyFile, p); err != nil {
		return nil, err
	}
	return p, Load(f.publicKeyFile, p.Public)
}

func (f *fileStore) LoadGroup() (*Group, error) {
	g := new(Group)
	return g, Load(f.groupFile, g)
}

func (f *fileStore) SaveGroup(g *Group) error {
	return Save(f.groupFile, g, false)
}

func (f *fileStore) SaveShare(share *Share) error {
	slog.Info("cryptostore: saving private share in ", f.shareFile)
	return Save(f.shareFile, share, true)
}

func (f *fileStore) LoadShare() (*Share, error) {
	s := new(Share)
	return s, Load(f.shareFile, s)
}

func (f *fileStore) SaveDistPublic(d *DistPublic) error {
	slog.Info("fileStore saving public distributed key in ", f.distKeyFile)
	return Save(f.distKeyFile, d, false)
}

func (f *fileStore) LoadDistPublic() (*DistPublic, error) {
	d := new(DistPublic)
	return d, Load(f.distKeyFile, d)
}

func Save(path string, t Tomler, secure bool) error {
	var fd *os.File
	var err error
	if secure {
		fd, err = createSecureFile(path)
	} else {
		fd, err = os.Create(path)
	}
	if err != nil {
		slog.Infof("config: can't save %s to %s: %s", reflect.TypeOf(t).String(), path, err)
		return nil
	}
	defer fd.Close()
	return toml.NewEncoder(fd).Encode(t.TOML())
}

func Load(path string, t Tomler) error {
	tomlValue := t.TOMLValue()
	var err error
	if _, err = toml.DecodeFile(path, tomlValue); err != nil {
		return err
	}
	return t.FromTOML(tomlValue)
}

func createSecureFolder(folder string) string {
	if exists, _ := exists(folder); !exists {
		if err := os.MkdirAll(folder, 0740); err != nil {
			panic(err)
		}
	}
	return folder
}

// pwd returns the current directory. Useless for now.
func pwd() string {
	s, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	return s
}

// exists returns whether the given file or directory exists or not
func exists(path string) (bool, error) {
	_, err := os.Stat(path)
	if err == nil {
		return true, nil
	}
	if os.IsNotExist(err) {
		return false, nil
	}
	return true, err
}

type context struct {
	KeyValue
}

func (c *context) String(key, def string) string {
	if c.KeyValue.IsSet(key) {
		return c.KeyValue.String(key)
	}
	return def
}

func createSecureFile(file string) (*os.File, error) {
	fd, err := os.Create(file)
	if err != nil {
		return nil, err
	}
	fd.Close()
	if err := os.Chmod(file, 0600); err != nil {
		return nil, nil
	}
	return os.OpenFile(file, os.O_RDWR, 0600)
}

// files returns the list of file names included in the given path or error if
// any.
func files(path string) ([]string, error) {
	fi, err := ioutil.ReadDir(path)
	if err != nil {
		return nil, err
	}
	var files []string
	for _, f := range fi {
		if !f.IsDir() {
			files = append(files, f.Name())
		}
	}
	return files, nil
}

// exists returns true if the given name is a file in the given path. name must
// be the "basename" of the file.
func fileExists(path string, name string) bool {
	list, err := files(path)
	if err != nil {
		return false
	}

	for _, l := range list {
		if l == name {
			return true
		}
	}

	return false
}
